<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JOEL Studio | Visual Content Studio</title>
    <link href="https://fonts.googleapis.com/css2?family=Heebo:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --gold: #d4af37;
            --gold-light: #f4e4bc;
            --black: #0a0a0a;
            --black-card: rgba(20,20,20,0.85);
            --white: #fff;
            --grey: #888;
            --emerald: #50C878;
            --glass: rgba(255,255,255,0.05);
        }
        * { margin:0; padding:0; box-sizing:border-box; }
        body { font-family:'Heebo',sans-serif; background:var(--black); color:var(--white); min-height:100vh; direction:rtl; }

        .header { position:fixed; top:0; left:0; right:0; z-index:100; background:rgba(10,10,10,0.95); padding:12px 20px; display:flex; justify-content:space-between; align-items:center; backdrop-filter:blur(10px); border-bottom:1px solid rgba(212,175,55,0.2); }
        .logo { font-size:1.8rem; font-weight:300; letter-spacing:0.2em; color:var(--gold); }
        .model-toggle { display:flex; gap:8px; }
        .model-btn { padding:8px 16px; border:1px solid var(--gold); background:transparent; color:var(--gold); cursor:pointer; font-family:inherit; font-size:0.85rem; transition:all 0.3s; border-radius:4px; }
        .model-btn.active { background:var(--gold); color:var(--black); }
        .collection-badge { padding:4px 12px; border-radius:20px; font-size:0.75rem; font-weight:600; }
        .badge-moissanite { background:var(--gold); color:var(--black); }
        .badge-emerald { background:var(--emerald); color:var(--black); }

        .main { display:flex; flex-direction:column; padding-top:60px; min-height:100vh; }

        .steps-nav { display:flex; justify-content:center; gap:10px; padding:15px; background:var(--black-card); border-bottom:1px solid rgba(212,175,55,0.1); flex-wrap:wrap; }
        .step-btn { padding:10px 20px; background:var(--glass); border:1px solid rgba(212,175,55,0.3); color:var(--grey); cursor:pointer; font-family:inherit; font-size:0.9rem; border-radius:6px; transition:all 0.3s; }
        .step-btn.active { background:var(--gold); color:var(--black); border-color:var(--gold); }
        .step-btn:hover { border-color:var(--gold); }

        .step-panel { display:none; flex:1; overflow-y:auto; }
        .step-panel.active { display:block; }

        .studio-layout { display:grid; grid-template-columns:1fr 320px; gap:20px; padding:20px; min-height:calc(100vh - 140px); }
        @media(max-width:900px) { .studio-layout { grid-template-columns:1fr; } }

        .catalog { background:var(--black-card); border-radius:12px; padding:15px; border:1px solid rgba(212,175,55,0.1); }
        .catalog-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; flex-wrap:wrap; gap:10px; }
        .catalog-title { font-size:1.1rem; color:var(--gold); }
        .catalog-count { font-size:0.85rem; color:var(--grey); }
        .products-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(140px,1fr)); gap:12px; max-height:calc(100vh - 280px); overflow-y:auto; padding:5px; }
        @media(max-width:600px) { .products-grid { grid-template-columns:repeat(2,1fr); max-height:50vh; } }
        .product-card { background:var(--glass); border:2px solid transparent; border-radius:8px; overflow:hidden; cursor:pointer; transition:all 0.3s; }
        .product-card:hover { border-color:rgba(212,175,55,0.5); transform:translateY(-2px); }
        .product-card.selected { border-color:var(--gold); box-shadow:0 0 20px rgba(212,175,55,0.3); }
        .product-img { width:100%; aspect-ratio:1; object-fit:cover; background:#1a1a1a; }
        .product-info { padding:8px; }
        .product-title { font-size:0.75rem; color:var(--white); line-height:1.3; display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; overflow:hidden; }
        .product-row { font-size:0.65rem; color:var(--grey); margin-top:4px; }

        .dashboard { background:var(--black-card); border-radius:12px; padding:20px; border:1px solid rgba(212,175,55,0.1); display:flex; flex-direction:column; height:fit-content; position:sticky; top:80px; }
        @media(max-width:900px) { .dashboard { position:relative; top:0; } }
        .dash-section { margin-bottom:20px; }
        .dash-label { font-size:0.8rem; color:var(--grey); margin-bottom:8px; display:block; }
        .dash-value { font-size:0.95rem; color:var(--white); padding:10px; background:var(--glass); border-radius:6px; min-height:40px; }
        .scene-categories { display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:10px; }
        .scene-cat-btn { padding:10px; background:var(--glass); border:1px solid rgba(212,175,55,0.2); color:var(--grey); cursor:pointer; font-family:inherit; font-size:0.8rem; border-radius:6px; transition:all 0.3s; }
        .scene-cat-btn.active { background:rgba(212,175,55,0.2); color:var(--gold); border-color:var(--gold); }
        select { width:100%; padding:10px; background:var(--glass); border:1px solid rgba(212,175,55,0.3); color:var(--white); font-family:inherit; font-size:0.9rem; border-radius:6px; cursor:pointer; }
        select option { background:var(--black); }
        .generate-btn { width:100%; padding:14px; background:linear-gradient(135deg,var(--gold),#b8972e); border:none; color:var(--black); font-family:inherit; font-size:1rem; font-weight:600; border-radius:8px; cursor:pointer; transition:all 0.3s; margin-top:auto; }
        .generate-btn:hover { transform:translateY(-2px); box-shadow:0 5px 20px rgba(212,175,55,0.4); }
        .generate-btn:disabled { opacity:0.5; cursor:not-allowed; transform:none; }

        .next-step-glow {
            box-shadow:0 0 0 rgba(212,175,55,0);
            border-color:rgba(212,175,55,0.9) !important;
            animation:next-step-glow-pulse 1.8s ease-in-out infinite;
        }
        @keyframes next-step-glow-pulse {
            0% { box-shadow:0 0 0 rgba(212,175,55,0.0); transform:translateY(0); }
            50% { box-shadow:0 0 18px rgba(212,175,55,0.7); transform:translateY(-1px); }
            100% { box-shadow:0 0 0 rgba(212,175,55,0.0); transform:translateY(0); }
        }

        .copywriter-layout { padding:20px; max-width:800px; margin:0 auto; }
        .result-frame { background:var(--black-card); border-radius:12px; border:1px solid rgba(212,175,55,0.2); overflow:hidden; margin-bottom:20px; }
        .result-placeholder { position:relative; width:100%; aspect-ratio:1; display:flex; align-items:center; justify-content:center; background:#111; color:var(--grey); flex-direction:column; gap:10px; }
        .shimmer { background:linear-gradient(90deg,#111 25%,#222 50%,#111 75%); background-size:200% 100%; animation:shimmer 1.5s infinite; }
        @keyframes shimmer { 0%{background-position:200% 0} 100%{background-position:-200% 0} }
        .result-actions { padding:15px; display:flex; gap:10px; flex-wrap:wrap; }
        .action-btn { flex:1; min-width:150px; padding:12px; border:none; font-family:inherit; font-size:0.9rem; font-weight:500; border-radius:8px; cursor:pointer; transition:all 0.3s; display:flex; align-items:center; justify-content:center; gap:8px; }
        .action-btn.btn-locked { opacity:0.3; cursor:not-allowed; pointer-events:none; }
        .btn-caption { background:linear-gradient(135deg,#4a90d9,#357abd); color:white; }
        .btn-telegram { background:linear-gradient(135deg,#0088cc,#006699); color:white; }
        .btn-instagram { background:linear-gradient(135deg,#833ab4,#fd1d1d,#fcb045); color:white; opacity:0.5; cursor:not-allowed; }
        .caption-box { background:var(--glass); border:1px solid rgba(212,175,55,0.2); border-radius:8px; padding:15px; margin-top:15px; }
        .caption-text { width:100%; min-height:120px; background:transparent; border:none; color:var(--white); font-family:inherit; font-size:0.95rem; line-height:1.6; resize:vertical; }
        .caption-text:focus { outline:none; }

        .distribution-layout { padding:20px; max-width:600px; margin:0 auto; text-align:center; }
        .final-preview { background:var(--black-card); border-radius:12px; padding:20px; border:1px solid rgba(212,175,55,0.2); }
        .distribution-btns { display:flex; flex-direction:column; gap:10px; }
        .dist-btn { padding:14px 20px; border:none; font-family:inherit; font-size:1rem; font-weight:500; border-radius:8px; cursor:pointer; transition:all 0.3s; }

        .status-row { display:flex; align-items:center; gap:10px; margin-top:8px; flex-wrap:wrap; }
        .status-bar { flex:1; min-width:200px; padding:6px 12px; min-height:28px; background:rgba(212,175,55,0.08); border-radius:4px; font-size:0.8rem; color:var(--gold); text-align:center; display:none; border-bottom:1px solid rgba(212,175,55,0.15); transition:opacity 0.5s ease; }
        .reset-btn { padding:6px 14px; font-size:0.8rem; background:rgba(212,175,55,0.15); border:1px solid rgba(212,175,55,0.4); color:var(--gold); border-radius:4px; cursor:pointer; font-family:inherit; transition:all 0.3s; white-space:nowrap; }
        .reset-btn:hover { background:rgba(212,175,55,0.25); }
        .status-bar.visible { display:block; }
        .status-bar.persona-shimmer .liran-name { background:linear-gradient(90deg,var(--gold),#f4e4bc,var(--gold)); background-size:200% 100%; -webkit-background-clip:text; background-clip:text; color:transparent; animation:persona-shimmer 2.5s ease-in-out infinite; }
        @keyframes persona-shimmer { 0%{background-position:200% 0} 100%{background-position:-200% 0} }
        .status-bar.persona-fade-in { animation:persona-fade-in 0.5s ease-out forwards; }
        @keyframes persona-fade-in { from{opacity:0.6} to{opacity:1} }
        .status-bar.persona-shimmer.persona-waiting { animation:persona-pulse 2s ease-in-out infinite; }
        .status-bar.persona-shimmer.persona-waiting .liran-name { animation:persona-shimmer 2.5s ease-in-out infinite; }
        @keyframes persona-pulse { 0%,100%{opacity:1} 50%{opacity:0.85} }
        .status-bar.error { background:rgba(255,0,0,0.1); color:#ff6b6b; }
        .status-bar.success { background:rgba(80,200,120,0.1); color:var(--emerald); }

        .loading-spinner { width:40px; height:40px; border:3px solid var(--glass); border-top-color:var(--gold); border-radius:50%; animation:spin 1s linear infinite; }
        @keyframes spin { to{transform:rotate(360deg)} }

        ::-webkit-scrollbar { width:6px; }
        ::-webkit-scrollbar-track { background:var(--black); }
        ::-webkit-scrollbar-thumb { background:var(--gold); border-radius:3px; }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">JOEL</div>
        <div style="display:flex;align-items:center;gap:15px;">
            <div class="model-toggle">
                <button class="model-btn active" data-model="Victoria">Victoria</button>
                <button class="model-btn" data-model="Alma">Alma</button>
            </div>
            <span class="collection-badge badge-moissanite" id="collectionBadge">MOISSANITE</span>
        </div>
    </header>

    <main class="main">
        <nav class="steps-nav">
            <button class="step-btn active" data-step="1">1. Studio</button>
            <button class="step-btn" data-step="2">2. Copywriter</button>
            <button class="step-btn" data-step="3">3. Distribution</button>
        </nav>
        <div class="status-row">
            <div class="status-bar" id="globalStatus"></div>
            <button type="button" class="reset-btn" id="hardResetBtn" title="◊®◊ô◊°◊ò ◊û◊ú◊ê">‚ü≤ Hard Reset</button>
        </div>

        <section class="step-panel active" id="step1">
            <div class="studio-layout">
                <div class="catalog">
                    <div class="catalog-header">
                        <span class="catalog-title">Product Catalog</span>
                        <span class="catalog-count" id="productCount">108 products</span>
                    </div>
                    <div class="products-grid" id="productsGrid"></div>
                </div>
                <div class="dashboard">
                    <div class="dash-section">
                        <span class="dash-label">Selected Product</span>
                        <div class="dash-value" id="selectedProduct">Select a product...</div>
                    </div>
                    <div class="dash-section">
                        <span class="dash-label">Scene Category</span>
                        <div class="scene-categories" id="sceneCategories">
                            <button class="scene-cat-btn" data-cat="daylight-urban">Daylight Urban</button>
                            <button class="scene-cat-btn" data-cat="glamour-night">Glamour Night</button>
                            <button class="scene-cat-btn" data-cat="luxury-vacation">Luxury Vacation</button>
                            <button class="scene-cat-btn" data-cat="quiet-luxury">Quiet Luxury</button>
                        </div>
                        <select id="sceneSelect" disabled><option value="">Select category first...</option></select>
                    </div>
                    <div class="dash-section">
                        <span class="dash-label">Creativity Level</span>
                        <select id="creativityLevel">
                            <option value="1">1 - Minimal</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5" selected>5 - Balanced</option>
                            <option value="6">6</option>
                            <option value="7">7</option>
                            <option value="8">8</option>
                            <option value="9">9</option>
                            <option value="10">10 - Maximum</option>
                        </select>
                    </div>
                    <div class="dash-section">
                        <span class="dash-label">Aspect Ratio</span>
                        <select id="aspectRatio">
                            <option value="1:1">1:1 Square</option>
                            <option value="9:16">9:16 Story</option>
                            <option value="16:9">16:9 Wide</option>
                            <option value="4:5">4:5 Portrait</option>
                        </select>
                    </div>
                    <button class="generate-btn" id="generateBtn" disabled>Generate Image</button>
                    <div class="status-bar" id="statusBar"></div>
                </div>
            </div>
        </section>

        <section class="step-panel" id="step2">
            <div class="copywriter-layout">
                <div class="result-frame">
                    <div class="result-placeholder" id="resultImage">
                        <div class="loading-spinner" style="display:none" id="imageSpinner"></div>
                        <span id="imagePlaceholder">Generate an image in Step 1</span>
                    </div>
                    <div class="result-actions">
                        <button type="button" class="action-btn btn-caption" id="captionBtn" disabled>üìù Generate Marketing Post</button>
                        <button class="action-btn btn-telegram" id="telegramBtn" disabled>üöÄ Send to Telegram</button>
                        <button class="action-btn btn-instagram" disabled>üì∏ Instagram (Soon)</button>
                    </div>
                </div>
                <div class="caption-box" id="captionBox" style="display:none">
                    <textarea class="caption-text" id="captionText" placeholder="Marketing text will appear here..."></textarea>
                </div>
                <div class="status-bar" id="step2Status"></div>
            </div>
        </section>

        <section class="step-panel" id="step3">
            <div class="distribution-layout">
                <div class="final-preview">
                    <h2 style="color:var(--gold);margin-bottom:20px;">Ready to Publish</h2>
                    <div id="finalContent"><p style="color:var(--grey);">Complete Steps 1 & 2 first</p></div>
                    <div class="distribution-btns" style="margin-top:20px;">
                        <button class="dist-btn btn-telegram" id="finalTelegram" disabled>üöÄ Publish to Telegram</button>
                        <button class="dist-btn btn-instagram" disabled>üì∏ Instagram (Coming Soon)</button>
                    </div>
                </div>
                <div class="status-bar" id="step3Status"></div>
            </div>
        </section>
    </main>

    <script src="products_verified.js"></script>
    <script>
        const WEBHOOK_IMAGE = 'https://hook.eu2.make.com/y3ckr5lpv25147c4l5zi5r9wfyd6kmvl';
        const WEBHOOK_CAPTION = 'https://hook.eu2.make.com/rseu4bjldsj15cm12wx0otg620ahrv67';
        // TODO: replace these with your real webhooks/endpoints
        // that read from the "Scenarios" and "Dashboard" sheets.
        const WEBHOOK_SCENARIOS = 'https://hook.eu2.make.com/sm6zjl2q1vjzsc4pu4xqd8wx318wpr73'; // e.g. 'https://hook.eu2.make.com/your-scenarios-webhook'
        const WEBHOOK_STATUS = 'https://hook.eu2.make.com/kayjcpyyjjx4rudihs3yz715jip8u1w7';    // e.g. 'https://hook.eu2.make.com/your-dashboard-status-webhook'

        const VICTORIA_PHRASES = [
            '◊ú◊ô◊®◊ü, ◊ë◊ï◊ì◊ß◊™ ◊©◊î◊™◊ê◊ï◊®◊î ◊ë◊°◊ò◊ï◊ì◊ô◊ï ◊û◊ó◊û◊ô◊ê◊î ◊ú◊¢◊í◊ô◊ú◊ô◊ù ◊õ◊û◊ï ◊©◊ë◊ô◊ß◊©◊™...',
            '◊ï◊ô◊ß◊ò◊ï◊®◊ô◊î ◊û◊ï◊°◊ô◊§◊î ◊ê◊ò◊ô◊ò◊ô◊ï◊ì ◊ê◊ï◊®◊ë◊†◊ô, ◊ú◊ô◊®◊ü - ◊™◊õ◊ô◊ü ◊ê◊™ ◊î◊ò◊ú◊í◊®◊ù, ◊ñ◊î ◊î◊ï◊ú◊ö ◊ú◊î◊ô◊ï◊™ ◊ê◊©!',
            '◊ú◊ô◊®◊ü, ◊°◊ë◊ú◊†◊ï◊™... ◊°◊ò◊ô◊ô◊ú ◊õ◊ñ◊î ◊ú◊ê ◊ë◊ï◊†◊ô◊ù ◊ë◊®◊í◊¢, ◊ê◊§◊ô◊ú◊ï ◊ú◊ê ◊ë◊©◊ë◊ô◊ú◊ö.',
            '◊û◊©◊ô◊ô◊§◊™ ◊ê◊™ ◊î◊ò◊ß◊°◊ò ◊©◊ô◊î◊ô◊î ◊ó◊ì ◊õ◊û◊ï ◊î◊°◊ò◊ô◊ô◊ú ◊©◊ú ◊ú◊ô◊®◊ü.'
        ];
        const ALMA_PHRASES = [
            '◊¢◊ú◊û◊ê ◊û◊ó◊§◊©◊™ ◊ñ◊ï◊ï◊ô◊™ ◊©◊ß◊ô◊¢◊î ◊©◊™◊§◊™◊ô◊¢ ◊ê◊§◊ô◊ú◊ï ◊ê◊ï◊™◊ö, ◊ú◊ô◊®◊ü...',
            '◊õ◊ï◊™◊ë◊™ ◊û◊©◊î◊ï ◊û◊î◊ú◊ë, ◊ú◊ô◊®◊ü. ◊î◊û◊ô◊ú◊ô◊ù ◊¶◊®◊ô◊õ◊ï◊™ ◊ú◊î◊ô◊ï◊™ ◊û◊ì◊ï◊ô◊ß◊ï◊™ ◊õ◊û◊ï ◊ê◊û◊®◊ú◊ì.',
            '◊û◊ú◊ò◊©◊™ ◊ê◊™ ◊î◊™◊ô◊ê◊ï◊®, ◊ú◊ô◊®◊ü - ◊ê◊†◊ó◊†◊ï ◊ô◊ï◊¶◊®◊ô◊ù ◊õ◊ê◊ü ◊®◊í◊¢ ◊ß◊°◊ï◊ù.',
            '◊ú◊ô◊®◊ü, ◊¢◊ï◊ì ◊®◊í◊¢ ◊ï◊ñ◊î ◊û◊ï◊õ◊ü. ◊î◊ô◊ï◊ß◊®◊î ◊û◊ó◊õ◊î ◊®◊ß ◊ú◊ö.'
        ];
        const RETRY_PHRASES = [
            '◊ú◊ô◊®◊ü, ◊ï◊ô◊ß◊ò◊ï◊®◊ô◊î ◊û◊§◊¢◊ô◊ú◊î ◊ê◊™ ◊û◊†◊í◊†◊ï◊ü ◊î-Retry... ◊î◊ô◊ê ◊ú◊ê ◊û◊ï◊ï◊™◊®◊™ ◊ú◊©◊®◊™ ◊¢◊ì ◊©◊î◊™◊û◊ï◊†◊î ◊™◊¶◊ê ◊û◊ï◊©◊ú◊û◊™.',
            '◊î-API ◊ß◊¶◊™ ◊¢◊û◊ï◊°, ◊ú◊ô◊®◊ü, ◊ê◊ë◊ú ◊¢◊ú◊û◊ê ◊õ◊ë◊® ◊ë◊†◊ô◊°◊ô◊ï◊ü ◊†◊ï◊°◊£. ◊¢◊ï◊ì ◊ß◊¶◊™ ◊°◊ë◊ú◊†◊ï◊™.',
            '◊ú◊ô◊®◊ü, ◊ê◊†◊ó◊†◊ï ◊ë◊û◊ï◊ì \'◊î◊û◊™◊†◊î ◊ó◊õ◊û◊î\'. ◊ï◊ô◊ß◊ò◊ï◊®◊ô◊î ◊ë◊ï◊ì◊ß◊™ ◊©◊î◊õ◊ú ◊û◊™◊ß◊ì◊ù ◊ú◊§◊ô ◊î◊™◊ï◊õ◊†◊ô◊™.'
        ];
        const TIMEOUT_MS = 12 * 60 * 1000;
        const POLL_INTERVAL_MS = 4000;
        const FAILURE_MESSAGE = '◊ú◊ô◊®◊ü, ◊†◊®◊ê◊î ◊©◊í◊ù 5 ◊†◊ô◊°◊ô◊ï◊†◊ï◊™ ◊ú◊ê ◊î◊°◊§◊ô◊ß◊ï. ◊ê◊ï◊ú◊ô ◊õ◊ì◊ê◊ô ◊ú◊ë◊ì◊ï◊ß ◊ê◊™ ◊î-API ◊ê◊ï ◊ú◊¢◊©◊ï◊™ ◊®◊ô◊°◊ò.';

        const SCENARIO_CATEGORIES = {
            'daylight-urban': 'Daylight Urban',
            'glamour-night': 'Glamour Night',
            'luxury-vacation': 'Luxury Vacation',
            'quiet-luxury': 'Quiet Luxury'
        };

        const scenariosByCategory = {
            'daylight-urban': [],
            'glamour-night': [],
            'luxury-vacation': [],
            'quiet-luxury': []
        };

        let selectedModel = 'Victoria';
        let selectedProduct = null;
        let selectedScene = '';
        let scenariosLoaded = false; // Credit protection: ensure loadScenarios runs only once

        const productsGrid = document.getElementById('productsGrid');
        const productCount = document.getElementById('productCount');
        const collectionBadge = document.getElementById('collectionBadge');
        const selectedProductEl = document.getElementById('selectedProduct');
        const sceneSelect = document.getElementById('sceneSelect');
        const generateBtn = document.getElementById('generateBtn');
        const statusBar = document.getElementById('statusBar');
        const captionBtn = document.getElementById('captionBtn');
        const telegramBtn = document.getElementById('telegramBtn');
        const captionBox = document.getElementById('captionBox');
        const captionText = document.getElementById('captionText');
        const resultImageEl = document.getElementById('resultImage');
        const imageSpinner = document.getElementById('imageSpinner');
        const imagePlaceholder = document.getElementById('imagePlaceholder');
        const globalStatusBar = document.getElementById('globalStatus');
        let userHasTriggeredGeneration = false;
        let statusPollingIntervalId = null;
        // Tracks where we are in a generation run: 'idle' | 'image' | 'caption'
        let generationPhase = 'idle';
        // Global state for current result
        let currentCaption = null;
        let currentImageUrl = null;
        // Polling safety
        let lastSeenStatus = '';
        let ignoreDoneUntil = 0; // timestamp (ms) until which DONE is ignored (10s after button click)
        let lastJ5Content = '';  // last value seen in J5
        let lastJ5ChangeAt = 0;  // when J5 last changed (reset on each change; timeout if unchanged for 12 min)
        let personaCycleIntervalId = null;
        let personaPhraseIndex = 0;

        function setNextStepGlow(targetEl) {
            const all = [generateBtn, captionBtn, telegramBtn];
            all.forEach(btn => {
                if (!btn) return;
                btn.classList.remove('next-step-glow');
            });
            if (targetEl && !targetEl.disabled) {
                targetEl.classList.add('next-step-glow');
            }
        }

        function getImageUrl(obj) {
            if (!obj) return null;
            if (typeof obj === 'string' && obj.trim()) return obj.trim();
            const u = obj.url || obj.imageUrl || obj.image_url || obj["0"] || obj[0];
            return (u != null && String(u).trim()) ? String(u).trim() : null;
        }

        function normalizeImageUrl(url) {
            if (!url) return url;
            let u = String(url).trim();
            // Dropbox share links often return HTML; convert to direct download so <img> can render it.
            if (u.includes('dropbox.com')) {
                // Normalize query params: dl=0 -> dl=1
                if (u.includes('dl=0')) u = u.replace('dl=0', 'dl=1');
                // If no dl/raw param exists, append raw=1
                if (!/[?&](dl|raw)=/i.test(u)) {
                    u += (u.includes('?') ? '&' : '?') + 'raw=1';
                }
            }
            return u;
        }

        function setGeneratedImageUrl(url) {
            if (!url) return;
            const normalizedUrl = normalizeImageUrl(url);
            currentImageUrl = normalizedUrl;
            const container = document.getElementById('resultImage');
            const spinner = document.getElementById('imageSpinner');
            const placeholder = document.getElementById('imagePlaceholder');
            if (container) {
                container.classList.remove('shimmer');
                if (spinner) spinner.style.display = 'none';
                if (placeholder) placeholder.style.display = 'none';
                let img = document.getElementById('generatedImage');
                if (!img) {
                    img = document.createElement('img');
                    img.id = 'generatedImage';
                    img.alt = 'Generated image';
                    img.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;display:block;';
                    container.appendChild(img);
                }
                img.onload = function () { console.log('Image loaded successfully:', img.src); };
                img.onerror = function () { console.error('Image failed to load:', img.src); };
                img.src = normalizedUrl;
                img.style.display = 'block';
            }
        }

        function wrapLiranWithShimmer(str) {
            if (!str || !str.includes('◊ú◊ô◊®◊ü')) return str;
            return str.replace(/◊ú◊ô◊®◊ü/g, '<span class="liran-name">◊ú◊ô◊®◊ü</span>');
        }

        function stopPersonaCycle() {
            if (personaCycleIntervalId) {
                clearInterval(personaCycleIntervalId);
                personaCycleIntervalId = null;
            }
            if (globalStatusBar) globalStatusBar.classList.remove('persona-shimmer', 'persona-fade-in', 'persona-waiting');
        }

        function showPersonaPhrase() {
            if (!globalStatusBar) return;
            const modelPhrases = selectedModel === 'Alma' ? ALMA_PHRASES : VICTORIA_PHRASES;
            const allPhrases = [...modelPhrases, ...RETRY_PHRASES];
            const phrase = allPhrases[personaPhraseIndex % allPhrases.length];
            personaPhraseIndex++;
            globalStatusBar.classList.remove('persona-fade-in');
            void globalStatusBar.offsetWidth;
            globalStatusBar.classList.add('persona-shimmer', 'persona-fade-in', 'persona-waiting', 'visible');
            globalStatusBar.innerHTML = wrapLiranWithShimmer(phrase);
            globalStatusBar.classList.remove('error', 'success');
        }

        function startPersonaCycle() {
            stopPersonaCycle();
            personaPhraseIndex = 0;
            showPersonaPhrase();
            const cycleMs = 5000 + Math.random() * 1000;
            personaCycleIntervalId = setInterval(showPersonaPhrase, cycleMs);
        }

        function setButtonLocked(el, locked) {
            if (!el) return;
            el.disabled = locked;
            if (locked) el.classList.add('btn-locked');
            else el.classList.remove('btn-locked');
        }

        function hardReset() {
            stopPersonaCycle();
            if (statusPollingIntervalId) {
                clearInterval(statusPollingIntervalId);
                statusPollingIntervalId = null;
            }
            userHasTriggeredGeneration = false;
            generationPhase = 'idle';
            lastJ5Content = '';
            lastJ5ChangeAt = 0;
            lastSeenStatus = '';
            currentCaption = null;
            currentImageUrl = null;
            if (captionText) captionText.value = '';
            if (captionBox) captionBox.style.display = 'none';
            if (globalStatusBar) {
                globalStatusBar.textContent = '';
                globalStatusBar.innerHTML = '';
                globalStatusBar.className = 'status-bar';
                globalStatusBar.classList.remove('visible', 'error', 'success');
            }
            if (statusBar) { statusBar.textContent = ''; statusBar.className = 'status-bar'; }
            const step2Status = document.getElementById('step2Status');
            if (step2Status) step2Status.textContent = '';
            generateBtn.disabled = !selectedProduct;
            setButtonLocked(captionBtn, true);
            setButtonLocked(telegramBtn, true);
            const finalT = document.getElementById('finalTelegram');
            if (finalT) { finalT.disabled = true; finalT.classList.add('btn-locked'); }
            if (captionBtn) captionBtn.textContent = 'üìù Generate Marketing Post';
            setNextStepGlow(selectedProduct ? generateBtn : null);
            // Reset result image to placeholder
            const container = document.getElementById('resultImage');
            const img = document.getElementById('generatedImage');
            const placeholder = document.getElementById('imagePlaceholder');
            const spinner = document.getElementById('imageSpinner');
            if (container) {
                container.classList.remove('shimmer');
                if (img) img.style.display = 'none';
                if (placeholder) { placeholder.style.display = 'block'; placeholder.textContent = 'Generate an image in Step 1'; }
                if (spinner) spinner.style.display = 'none';
            }
            startStatusPolling();
        }

        function init() {
            renderProducts();
            setupEventListeners();
            loadScenarios();
            startStatusPolling();
            // Default: Generate Image can glow when product+scene selected; Post & Telegram LOCKED
            if (captionBtn) setButtonLocked(captionBtn, true);
            if (telegramBtn) setButtonLocked(telegramBtn, true);
            const finalT = document.getElementById('finalTelegram');
            if (finalT) { finalT.disabled = true; finalT.classList.add('btn-locked'); }
            if (globalStatusBar) {
                globalStatusBar.textContent = 'Waiting for action...';
                globalStatusBar.classList.add('visible');
            }
        }

        // --- Scenarios: load from "Scenarios" sheet and group by category ---
        // One-time run: fetchScenarios runs ONLY ONCE on load to prevent burning credits.
        async function loadScenarios() {
            if (scenariosLoaded) {
                console.log('loadScenarios: Already loaded, skipping (one-time run).');
                return;
            }

            if (!WEBHOOK_SCENARIOS) {
                console.warn('WEBHOOK_SCENARIOS endpoint is not configured.');
                return;
            }

            try {
                const res = await fetch(WEBHOOK_SCENARIOS);
                if (!res.ok) throw new Error('HTTP ' + res.status);

                let data;
                let rawText;
                try {
                    rawText = await res.text();
                    console.log('RAW_TEXT_FROM_SCENARIOS_WEBHOOK:', rawText);
                    data = JSON.parse(rawText);
                } catch (parseErr) {
                    console.error('Scenarios webhook did not return valid JSON:', parseErr);
                    console.error('Raw response text that failed to parse:', rawText || '(could not read text)');
                    showStatus(statusBar, '‚úó Scenarios: response is not valid JSON', 'error');
                    return;
                }

                console.log('RAW_FROM_MAKE:', data);

                // ◊†◊®◊û◊ï◊ú data.scenes: Make ◊ú◊§◊¢◊û◊ô◊ù ◊û◊ó◊ñ◊ô◊® ◊û◊¢◊®◊ö ◊¢◊ò◊ï◊£ (length=1) ◊ê◊ï ◊û◊ó◊®◊ï◊ñ◊™ ‚Äì ◊û◊§◊ô◊ß◊ô◊ù ◊û◊¢◊®◊ö ◊ê◊ï◊ë◊ô◊ô◊ß◊ò◊ô◊ù
                if (!data || typeof data !== 'object') {
                    console.error('Expected payload: { scenes: [...] }. Received:', data);
                    showStatus(statusBar, '‚úó Scenarios: expected data.scenes', 'error');
                    return;
                }
                let scenariosArray = [];
                const raw = data.scenes;
                if (typeof raw === 'string') {
                    try {
                        const parsed = JSON.parse(raw);
                        scenariosArray = Array.isArray(parsed) ? parsed : (parsed && typeof parsed === 'object' ? [parsed] : []);
                    } catch (e) { scenariosArray = []; }
                } else if (Array.isArray(raw)) {
                    // Make ◊û◊ó◊ñ◊ô◊® ◊û◊¢◊®◊ö ◊©◊ú ◊û◊ó◊®◊ï◊ñ◊ï◊™ ‚Äì ◊õ◊ú ◊û◊ó◊®◊ï◊ñ◊™ ◊î◊ô◊ê ◊ê◊ï◊ë◊ô◊ô◊ß◊ò ◊ë-JSON; ◊û◊§◊®◊°◊ô◊ù ◊õ◊ú ◊ê◊ô◊ë◊®
                    raw.forEach(function (el) {
                        if (typeof el === 'string') {
                            try {
                                const parsed = JSON.parse(el);
                                if (Array.isArray(parsed)) scenariosArray.push.apply(scenariosArray, parsed);
                                else if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) scenariosArray.push(parsed);
                            } catch (e) { /* ◊ì◊ô◊ú◊ï◊í ◊¢◊ú ◊û◊ó◊®◊ï◊ñ◊™ ◊©◊ú◊ê ◊§◊®◊°◊î */ }
                        } else if (el && typeof el === 'object' && !Array.isArray(el)) {
                            scenariosArray.push(el);
                        }
                    });
                    // ◊ê◊ù ◊ô◊© ◊®◊ß ◊ê◊ô◊ë◊® ◊ê◊ó◊ì ◊ï◊î◊ï◊ê ◊û◊ó◊®◊ï◊ñ◊™ ‚Äì ◊†◊ô◊°◊ô◊ï◊ü ◊ú◊§◊®◊°◊ï◊ù: ◊û◊¢◊®◊ö ◊õ◊û◊ó◊®◊ï◊ñ◊™, ◊ê◊ï ◊ê◊ï◊ë◊ô◊ô◊ß◊ò ◊ë◊ï◊ì◊ì, ◊ê◊ï ◊©◊®◊©◊®◊™ ◊ê◊ï◊ë◊ô◊ô◊ß◊ò◊ô◊ù
                    if (scenariosArray.length === 0 && raw.length === 1 && typeof raw[0] === 'string') {
                        var s = raw[0].trim();
                        try {
                            var parsed = JSON.parse(s);
                            scenariosArray = Array.isArray(parsed) ? parsed : (parsed && typeof parsed === 'object' ? [parsed] : []);
                        } catch (e1) {
                            try {
                                var start = s.indexOf('[');
                                var end = s.lastIndexOf(']');
                                if (start !== -1 && end !== -1 && end > start) {
                                    parsed = JSON.parse(s.substring(start, end + 1));
                                    scenariosArray = Array.isArray(parsed) ? parsed : [];
                                }
                            } catch (e2) { }
                            if (scenariosArray.length === 0 && (s.indexOf('"0"') !== -1 || s.indexOf('"5"') !== -1)) {
                                var parts = s.split(/\}\s*,\s*\{/);
                                parts.forEach(function (part) {
                                    part = part.trim();
                                    if (!part) return;
                                    if (part.charAt(0) !== '{') part = '{' + part;
                                    if (part.charAt(part.length - 1) !== '}') part = part + '}';
                                    try {
                                        var obj = JSON.parse(part);
                                        if (obj && typeof obj === 'object' && !Array.isArray(obj)) scenariosArray.push(obj);
                                    } catch (e3) { }
                                });
                            }
                        }
                    }
                }
                if (!Array.isArray(scenariosArray) || scenariosArray.length === 0) {
                    console.error('Could not get array of objects from data.scenes. raw type:', typeof raw, 'raw length:', raw && raw.length);
                    showStatus(statusBar, '‚úó Scenarios: no valid scene objects (check webhook format)', 'error');
                    return;
                }
                console.log('data.scenes length (after normalize):', scenariosArray.length);

                Object.keys(scenariosByCategory).forEach(key => { scenariosByCategory[key] = []; });

                let rowsProcessed = 0;
                const allScenes = [];

                const CATEGORY_NAMES = ['Daylight Urban', 'Quiet Luxury', 'Glamour Night', 'Luxury Vacation'];
                function getCategoryFromItem(item) {
                    const from5 = item["5"] ?? item[5];
                    if (from5 != null && String(from5).trim()) return String(from5).trim().replace(/\s+/g, ' ');
                    const vals = Object.values(item);
                    const found = vals.find(function (v) {
                        if (typeof v !== 'string') return false;
                        const s = v.trim();
                        return CATEGORY_NAMES.some(function (c) { return c === s || c.toLowerCase() === s.toLowerCase(); });
                    });
                    return found ? String(found).trim().replace(/\s+/g, ' ') : '';
                }
                // ◊™◊ô◊ß◊ï◊ü ◊û◊ô◊§◊ï◊ô: ◊©◊ù ◊°◊¶◊†◊î ◊û-item["0"] ◊ê◊ï item[0], ◊ß◊ò◊í◊ï◊®◊ô◊î ◊û-item["5"] ◊ê◊ï ◊ó◊ô◊§◊ï◊© ◊¢◊®◊ö ◊©◊™◊ï◊ê◊ù ◊ú◊ê◊ó◊™ ◊û◊ê◊®◊ë◊¢ ◊î◊ß◊ò◊í◊ï◊®◊ô◊ï◊™
                scenariosArray.forEach((item, idx) => {
                    if (!item || typeof item !== 'object') return;

                    const rawName = item["0"] ?? item[0];
                    if (rawName == null) return;
                    const sceneStr = String(rawName).trim();
                    if (!sceneStr) return;
                    const catStr = getCategoryFromItem(item);
                    if (!catStr) return;

                    // ◊ì◊ô◊ú◊ï◊í ◊¢◊ú ◊©◊ï◊®◊™ ◊õ◊ï◊™◊®◊™ ◊ê◊ù ◊ß◊ô◊ô◊û◊™
                    const lowerScene = sceneStr.toLowerCase();
                    const lowerCat = catStr.toLowerCase();
                    if (idx === 0 && (lowerScene.includes('vibe') || lowerScene.includes('scene') || lowerScene.includes('name') || lowerCat.includes('category'))) return;

                    const catKey = Object.keys(SCENARIO_CATEGORIES)
                        .find(k => SCENARIO_CATEGORIES[k] === catStr || SCENARIO_CATEGORIES[k].toLowerCase() === catStr.toLowerCase());
                    if (!catKey) {
                        console.warn('Unknown category at row', idx, catStr);
                        return;
                    }

                    const value = sceneStr;
                    const label = sceneStr;
                    scenariosByCategory[catKey].push({ value, label });
                    allScenes.push({ name: sceneStr, category: catStr, value, label });
                    rowsProcessed++;
                });

                console.log('Processed Scenes:', allScenes);
                console.log('Final Data Structure:', scenariosByCategory);

                if (!rowsProcessed) {
                    showStatus(statusBar, '‚úó Scenarios: no valid rows after mapping', 'error');
                } else if (statusBar) {
                    statusBar.textContent = '';
                    statusBar.className = 'status-bar';
                }

                scenariosLoaded = true;

                // ◊†◊ô◊ß◊ï◊ô UI: ◊û◊û◊ï◊ú◊ê◊ï◊™ ◊ê◊®◊ë◊¢ ◊î◊ß◊ò◊í◊ï◊®◊ô◊ï◊™ ‚Äì ◊û◊û◊ú◊ê◊ô◊ù ◊ê◊™ ◊î-dropdown ◊©◊ú ◊õ◊ú ◊ß◊ò◊í◊ï◊®◊ô◊î
                const catKeys = ['daylight-urban', 'glamour-night', 'luxury-vacation', 'quiet-luxury'];
                document.querySelectorAll('.scene-cat-btn').forEach((btn, i) => {
                    const catKey = catKeys[i];
                    const scenes = scenariosByCategory[catKey] || [];
                    // ◊õ◊ú ◊ß◊ò◊í◊ï◊®◊ô◊î ◊õ◊ë◊® ◊û◊ß◊ï◊©◊®◊™ ◊ú-scenariosByCategory; ◊ë◊®◊í◊¢ ◊©◊ú◊ï◊ó◊¶◊ô◊ù ‚Äì ◊î-select ◊û◊™◊û◊ú◊ê
                });
                // ◊ë◊ï◊ó◊®◊ô◊ù ◊ê◊™ ◊î◊ß◊ò◊í◊ï◊®◊ô◊î ◊î◊®◊ê◊©◊ï◊†◊î ◊©◊ô◊© ◊ë◊î ◊°◊¶◊†◊ï◊™ ◊ï◊û◊û◊ú◊ê◊ô◊ù ◊ê◊™ ◊î-select
                const firstCatWithScenes = catKeys.find(k => (scenariosByCategory[k] || []).length > 0);
                if (firstCatWithScenes) {
                    document.querySelectorAll('.scene-cat-btn').forEach(b => b.classList.remove('active'));
                    const firstBtn = document.querySelector(`.scene-cat-btn[data-cat="${firstCatWithScenes}"]`);
                    if (firstBtn) {
                        firstBtn.classList.add('active');
                        const scenes = scenariosByCategory[firstCatWithScenes];
                        sceneSelect.disabled = false;
                        sceneSelect.innerHTML = '<option value="">Select scene...</option>' +
                            scenes.map(s => `<option value="${s.value}">${s.label}</option>`).join('');
                    }
                } else {
                    sceneSelect.disabled = true;
                    sceneSelect.innerHTML = '<option value="">No scenes loaded</option>';
                }
            } catch (err) {
                console.error('Failed to load scenarios', err);
                showStatus(statusBar, '‚úó Error loading scenarios', 'error');
            }
        }

        function renderProducts() {
            const filtered = PRODUCTS_DATA.filter(p => {
                if (selectedModel === 'Victoria') return p.collection === 'Moissanite';
                return p.collection === 'Emerald';
            });

            productCount.textContent = `${filtered.length} products`;
            productsGrid.innerHTML = filtered.map(p => `
                <div class="product-card" data-id="${p.id}" data-row="${p.rowNumber}">
                    <img class="product-img" src="${p.image}" alt="${p.title}" loading="lazy" onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%231a1a1a%22 width=%22100%22 height=%22100%22/></svg>'">
                    <div class="product-info">
                        <div class="product-title">${p.title}</div>
                        <div class="product-row">Row ${p.rowNumber}</div>
                    </div>
                </div>
            `).join('');

            document.querySelectorAll('.product-card').forEach(card => {
                card.addEventListener('click', () => selectProduct(card.dataset.id));
            });
        }

        function selectProduct(productId) {
            selectedProduct = PRODUCTS_DATA.find(p => p.id === productId);
            document.querySelectorAll('.product-card').forEach(c => c.classList.remove('selected'));
            document.querySelector(`[data-id="${productId}"]`)?.classList.add('selected');
            selectedProductEl.textContent = selectedProduct ? selectedProduct.title : 'Select a product...';
            updateGenerateBtn();
        }

        function setupEventListeners() {
            document.querySelectorAll('.model-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.model-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    selectedModel = btn.dataset.model;
                    collectionBadge.textContent = selectedModel === 'Victoria' ? 'MOISSANITE' : 'EMERALD';
                    collectionBadge.className = 'collection-badge ' + (selectedModel === 'Victoria' ? 'badge-moissanite' : 'badge-emerald');
                    selectedProduct = null;
                    selectedProductEl.textContent = 'Select a product...';
                    renderProducts();
                    updateGenerateBtn();
                });
            });

            document.querySelectorAll('.step-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.step-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.step-panel').forEach(p => p.classList.remove('active'));
                    btn.classList.add('active');
                    document.getElementById('step' + btn.dataset.step).classList.add('active');
                });
            });

            document.querySelectorAll('.scene-cat-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.scene-cat-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const catKey = btn.dataset.cat;
                    const scenes = scenariosByCategory[catKey] || [];

                    // Scene selector should always remain enabled so user can re-select scenes
                    sceneSelect.disabled = false;
                    if (!scenes.length) {
                        sceneSelect.innerHTML = '<option value=\"\">No scenes available for this category</option>';
                    } else {
                        sceneSelect.innerHTML =
                            '<option value=\"\">Select scene...</option>' +
                            scenes.map(s => `<option value=\"${s.value}\">${s.label}</option>`).join('');
                    }
                });
            });

            sceneSelect.addEventListener('change', function () {
                selectedScene = sceneSelect.value;
                updateGenerateBtn();
                if (selectedProduct && !generateBtn.disabled) {
                    setNextStepGlow(generateBtn);
                }
            });
            generateBtn.addEventListener('click', function () {
                setNextStepGlow(null);
                generateImage();
            });
            if (captionBtn) {
                captionBtn.addEventListener('click', function(e) { 
                    e.preventDefault(); 
                    setNextStepGlow(null);
                    generateCaption(); 
                });
            }
            telegramBtn.addEventListener('click', function () {
                setNextStepGlow(null);
                sendToTelegram();
            });
            document.getElementById('finalTelegram').addEventListener('click', function () {
                setNextStepGlow(null);
                sendToTelegram();
            });
            const hardResetBtn = document.getElementById('hardResetBtn');
            if (hardResetBtn) hardResetBtn.addEventListener('click', hardReset);
        }

        // Unlock: Generate Image enabled when a product is selected (no mandatory scene dependency)
        function updateGenerateBtn() {
            generateBtn.disabled = !selectedProduct;
        }

        function showStatus(el, msg, type = '') {
            el.textContent = msg;
            el.className = 'status-bar visible ' + type;
        }

        // --- Live dashboard status polling (Victoria_Dashboard: J5 = status, B5 = image URL, D5 = caption) ---
        async function fetchDashboardStatus() {
            if (!WEBHOOK_STATUS || !globalStatusBar) return;
            try {
                const res = await fetch(WEBHOOK_STATUS);
                if (!res.ok) throw new Error('HTTP ' + res.status);

                let data;
                let rawText;
                try {
                    rawText = await res.text();
                    data = JSON.parse(rawText);
                } catch (parseErr) {
                    console.error('Status webhook did not return valid JSON:', parseErr);
                    return;
                }
                // J5 = status cell (source of truth)
                const textRaw = data.J5 || data.j5 || data.status || data.value || data.statusText || data.A2 || '';
                const text = (textRaw || '').toString().trim();

                // Reset stale timer whenever J5 content changes
                if (text !== lastJ5Content) {
                    lastJ5Content = text;
                    lastJ5ChangeAt = Date.now();
                }
                // Timeout only if J5 has a value AND has stayed unchanged for 12 min (never timeout while J5 is empty)
                if (userHasTriggeredGeneration && text && lastJ5ChangeAt && (Date.now() - lastJ5ChangeAt > TIMEOUT_MS)) {
                    stopPersonaCycle();
                    if (statusPollingIntervalId) {
                        clearInterval(statusPollingIntervalId);
                        statusPollingIntervalId = null;
                    }
                    globalStatusBar.innerHTML = wrapLiranWithShimmer(FAILURE_MESSAGE);
                    globalStatusBar.classList.add('visible', 'error', 'persona-shimmer');
                    return;
                }
                if (text === '' && !userHasTriggeredGeneration) return;

                const trimmedText = text.trim();
                const isDone = trimmedText.toUpperCase() === 'DONE';

                // Ignore stale DONE for 10s after button click
                if (isDone && Date.now() < ignoreDoneUntil) return;

                // Avoid re-processing same status
                if (text === lastSeenStatus && isDone) return;
                if (isDone) lastSeenStatus = text;

                const handleCaptionPayload = (payloadText) => {
                    const cleanText = (payloadText || '').toString().trim();
                    if (!cleanText) return;
                    stopPersonaCycle();
                    currentCaption = cleanText;
                    const captionArea = document.getElementById('captionText');
                    const captionContainer = document.getElementById('captionBox');
                    if (captionContainer) captionContainer.style.display = 'block';
                    if (captionArea) captionArea.value = cleanText;
                    if (imageSpinner) imageSpinner.style.display = 'none';
                    if (resultImageEl) resultImageEl.classList.remove('shimmer');
                    globalStatusBar.textContent = '‚úì Post Ready';
                    globalStatusBar.classList.add('visible');
                    const step2Status = document.getElementById('step2Status');
                    if (step2Status) showStatus(step2Status, '‚úì Post Ready', 'success');
                    if (captionBtn) { setButtonLocked(captionBtn, false); captionBtn.textContent = 'üìù Generate Marketing Post'; }
                    setButtonLocked(telegramBtn, false);
                    const finalTelegramBtn = document.getElementById('finalTelegram');
                    if (finalTelegramBtn) { finalTelegramBtn.disabled = false; finalTelegramBtn.classList.remove('btn-locked'); }
                    setNextStepGlow(telegramBtn);
                };

                // J5 === 'DONE' ‚Üí current process finished
                if (isDone && userHasTriggeredGeneration) {
                    stopPersonaCycle();
                    if (generationPhase === 'image') {
                        // Image stage: URL from B5 only
                        const urlFromSheet = (data.B5 || data.b5 || '').toString().trim();
                        if (urlFromSheet) setGeneratedImageUrl(urlFromSheet);
                        globalStatusBar.textContent = '‚úì Image Ready';
                        globalStatusBar.classList.add('visible');
                        setButtonLocked(captionBtn, false);
                        generationPhase = 'caption';
                        setNextStepGlow(captionBtn);
                        // Telegram stays locked until post is done
                    } else {
                        // Post stage: caption from D5 only
                        const captionFromD5 = (data.D5 || data.d5 || '').toString().trim();
                        if (captionFromD5) handleCaptionPayload(captionFromD5);
                        generationPhase = 'idle';
                    }
                    if (statusPollingIntervalId) { clearInterval(statusPollingIntervalId); statusPollingIntervalId = null; }
                    return;
                }

                // J5 is anything else: display that text in status bar (never show raw URL)
                if (userHasTriggeredGeneration && text) {
                    const looksLikeUrl = /^https?:\/\//i.test(text);
                    globalStatusBar.textContent = looksLikeUrl ? '‚úì Ready' : text;
                    globalStatusBar.classList.remove('persona-shimmer');
                    globalStatusBar.classList.add('visible');
                }
            } catch (err) {
                console.error('Status polling error', err);
            }
        }

        function startStatusPolling() {
            fetchDashboardStatus();
            if (statusPollingIntervalId) {
                clearInterval(statusPollingIntervalId);
            }
            statusPollingIntervalId = setInterval(fetchDashboardStatus, POLL_INTERVAL_MS);
        }

        async function generateImage() {
            // ABSOLUTE STATE PURGE (must be first line)
            currentCaption = null; currentImageUrl = null; if (captionText) captionText.value = '';
            if (!selectedProduct) return;
            // During action: disable button immediately, 10s ignore DONE, status = Processing...
            generateBtn.disabled = true;
            ignoreDoneUntil = Date.now() + 10000;
            lastSeenStatus = '';
            lastJ5Content = '';
            lastJ5ChangeAt = Date.now();
            if (globalStatusBar) { globalStatusBar.textContent = 'Processing...'; globalStatusBar.classList.add('visible'); }
            startPersonaCycle();
            userHasTriggeredGeneration = true;
            generationPhase = 'image';
            console.log('SENDING REQUEST FOR MODEL:', selectedModel);

            // Clean reset: clear caption box, hide old image, remove glow, lock Post & Telegram
            setNextStepGlow(null);
            if (captionText) captionText.value = '';
            if (captionBox) captionBox.style.display = 'none';
            setButtonLocked(captionBtn, true);
            setButtonLocked(telegramBtn, true);
            const finalT = document.getElementById('finalTelegram');
            if (finalT) { finalT.disabled = true; finalT.classList.add('btn-locked'); }
            if (statusBar) { statusBar.textContent = ''; statusBar.className = 'status-bar'; }
            const step2Status = document.getElementById('step2Status');
            if (step2Status) {
                step2Status.textContent = '';
                step2Status.className = 'status-bar';
            }
            const imgEl = document.getElementById('generatedImage');
            if (imgEl) {
                imgEl.src = '';
                imgEl.style.display = 'none';
            }
            if (resultImageEl) {
                resultImageEl.classList.remove('shimmer');
            }
            if (imagePlaceholder) {
                imagePlaceholder.style.display = 'none';
            }

            // ◊û◊¢◊ë◊® ◊ú◊©◊ï◊†◊ô◊™: ◊ë◊ú◊ó◊ô◊¶◊î ◊¢◊ú 'Generate Image' ◊¢◊ï◊ë◊®◊ô◊ù ◊û◊ô◊ì ◊ú◊ú◊©◊ï◊†◊ô◊™ Copywriter (2)
            document.querySelectorAll('.step-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.step-panel').forEach(p => p.classList.remove('active'));
            document.querySelector('[data-step="2"]').classList.add('active');
            document.getElementById('step2').classList.add('active');

            showStatus(statusBar, '‚öôÔ∏è Generating image...');
            generateBtn.disabled = true;

            // Prepare live image placeholder + shimmer
            if (imageSpinner) imageSpinner.style.display = 'block';
            if (imagePlaceholder) {
                imagePlaceholder.style.display = 'block';
                imagePlaceholder.textContent = 'Image generation in progress...';
            }
            if (resultImageEl) resultImageEl.classList.add('shimmer');

            // Verify payload: pull current value from #sceneSelect right before sending
            const sceneSelectEl = document.getElementById('sceneSelect');
            const currentSceneValue = sceneSelectEl ? (sceneSelectEl.value || '') : (selectedScene || '');
            const formattedScene = currentSceneValue.includes(',')
                ? currentSceneValue.replace(',', ' - ')
                : currentSceneValue;

            // Ensure Alma's reference image URL is correct
            let modelUrl = selectedProduct.modelUrl;
            if (selectedModel === 'Alma') {
                modelUrl = 'https://res.cloudinary.com/dtapjwtqw/image/upload/v1769810294/liranhe_Glamorous_portrait_of_a_captivating_woman_with_exotic_f_90e9b0f9-f99e-4553-9a00-cc7f73a3c494_f7ffkh.png';
            }

            // Build model-specific prompt instructions
            const modelPrompt = selectedModel === 'Alma' 
                ? 'Model: Alma - A glamorous, captivating woman with exotic features. Use Alma\'s name and traits in the prompt.'
                : 'Model: Victoria - Use Victoria\'s name and traits in the prompt.';

            const payload = {
                source: 'Web_App',
                product_id: selectedProduct.id,
                rowNumber: selectedProduct.rowNumber,
                product: selectedProduct.title,
                model: selectedModel,
                collection: selectedProduct.collection,
                model_url: modelUrl,
                scene: formattedScene,
                situation: formattedScene, // Add situation field with formatted value
                aspect_ratio: document.getElementById('aspectRatio').value,
                creativity: parseInt(document.getElementById('creativityLevel').value),
                model_prompt: modelPrompt,
                scale_law: 'The jewelry must be visually reduced by 500% to stay dainty and realistic. Use delicate proportions.',
                command: 'Generate Image'
            };

            try {
                console.log('Request sent'); // Log to console when webhook is triggered
                const res = await fetch(WEBHOOK_IMAGE, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!res.ok) {
                    showStatus(statusBar, '‚úó Error sending image request', 'error');
                } else {
                    let data = null;
                    let rawText = await res.text();
                    const rawTrimmed = (rawText || '').trim();
                    console.log('RAW_TEXT_FROM_IMAGE_WEBHOOK:', rawText);

                    if (rawTrimmed === 'Accepted') {
                        showStatus(statusBar, 'Request accepted, polling for image...', 'success');
                        if (WEBHOOK_STATUS) {
                            const pollMs = 5000;
                            const pollDurationMs = 60000;
                            let elapsed = 0;
                            const pollOnce = async function () {
                                if (elapsed >= pollDurationMs) return;
                                try {
                                    const statusRes = await fetch(WEBHOOK_STATUS);
                                    if (!statusRes.ok) return;
                                    const statusText = await statusRes.text();
                                    let statusData = null;
                                    try { statusData = JSON.parse(statusText); } catch (e) { return; }
                                    let url = null;
                                    if (statusData) {
                                        if (typeof statusData.J5 === 'string' && statusData.J5.trim().startsWith('http')) url = statusData.J5.trim();
                                        else if (typeof statusData.j5 === 'string' && statusData.j5.trim().startsWith('http')) url = statusData.j5.trim();
                                        else url = getImageUrl(statusData) || (statusData.output && getImageUrl(statusData.output)) || (statusData.data && getImageUrl(statusData.data)) || (statusData.result && getImageUrl(statusData.result)) || (Array.isArray(statusData) && statusData.length && getImageUrl(statusData[0]));
                                    }
                                    if (url) {
                                        setGeneratedImageUrl(url);
                                        showStatus(statusBar, '‚úì Image generated successfully', 'success');
                                        setButtonLocked(captionBtn, false);
                                        generationPhase = 'caption';
                                        setNextStepGlow(captionBtn);
                                        return true;
                                    }
                                } catch (err) { console.warn('Poll fetch failed', err); }
                                return false;
                            };
                            const runPoll = async function () {
                                if (await pollOnce()) return;
                                elapsed += pollMs;
                                if (elapsed < pollDurationMs) setTimeout(runPoll, pollMs);
                            };
                            runPoll();
                        }
                    } else if (rawTrimmed.startsWith('{')) {
                        try {
                            data = JSON.parse(rawText);
                        } catch (e) {
                            console.warn('Image webhook JSON parse failed.', e);
                        }
                        const directUrl = data && (typeof data.url === 'string' && data.url.trim() ? data.url.trim() : getImageUrl(data) || (data.output && getImageUrl(data.output)) || (data.data && getImageUrl(data.data)) || (data.result && getImageUrl(data.result)) || (Array.isArray(data) && data.length && getImageUrl(data[0])));
                        if (directUrl) {
                            setGeneratedImageUrl(directUrl);
                            showStatus(statusBar, '‚úì Image generated successfully', 'success');
                            setButtonLocked(captionBtn, false);
                            generationPhase = 'caption';
                            setNextStepGlow(captionBtn);
                        } else {
                            showStatus(statusBar, '‚úì Request sent! Waiting for image...', 'success');
                        }
                    } else {
                        showStatus(statusBar, '‚úì Request sent! Waiting for image...', 'success');
                    }
                }
            } catch (err) {
                stopPersonaCycle();
                showStatus(statusBar, '‚úó Network error: ' + err.message, 'error');
            }
            generateBtn.disabled = false;
            updateGenerateBtn();
        }

        async function generateCaption() {
            if (!selectedProduct) return;
            // During action: disable button immediately, 10s ignore DONE, status = Processing...
            if (captionBtn) {
                captionBtn.disabled = true;
                captionBtn.classList.add('btn-locked');
                captionBtn.textContent = 'Generating Caption...';
            }
            ignoreDoneUntil = Date.now() + 10000;
            lastSeenStatus = '';
            lastJ5Content = '';
            lastJ5ChangeAt = Date.now();
            if (globalStatusBar) { globalStatusBar.textContent = 'Processing...'; globalStatusBar.classList.add('visible'); }
            startPersonaCycle();
            const status = document.getElementById('step2Status');
            showStatus(status, 'Generating Caption...');
            console.log('SENDING REQUEST FOR MODEL (caption):', selectedModel);

            // Format scene (Product Data + Prompt) for caption webhook
            const sceneRaw = selectedScene || '';
            const formattedScene = sceneRaw.includes(',') ? sceneRaw.replace(',', ' - ') : sceneRaw;

            // Ensure Alma's reference image URL is correct
            let modelUrl = selectedProduct.modelUrl;
            if (selectedModel === 'Alma') {
                modelUrl = 'https://res.cloudinary.com/dtapjwtqw/image/upload/v1769810294/liranhe_Glamorous_portrait_of_a_captivating_woman_with_exotic_f_90e9b0f9-f99e-4553-9a00-cc7f73a3c494_f7ffkh.png';
            }

            // Build model-specific prompt instructions
            const modelPrompt = selectedModel === 'Alma' 
                ? 'Model: Alma - A glamorous, captivating woman with exotic features. Use Alma\'s name and traits in the prompt.'
                : 'Model: Victoria - Use Victoria\'s name and traits in the prompt.';

            const fixedUrl = modelUrl.replace('www.dropbox.com', 'dl.dropboxusercontent.com').replace('dl=0', 'raw=1');
                
            const payload = {
                source: 'Web_App',
                product_id: selectedProduct.id,
                rowNumber: selectedProduct.rowNumber,
                product: selectedProduct.title,
                model: selectedModel,
                collection: selectedProduct.collection,
                model_url: fixedUrl,
                scene: formattedScene,
                situation: formattedScene,
                model_prompt: modelPrompt,
                prompt: formattedScene,
                command: 'Generate Caption'
            };

            try {
                console.log('Caption request sent to', WEBHOOK_CAPTION, { product: selectedProduct.title, scene: formattedScene });
                const res = await fetch(WEBHOOK_CAPTION, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!res.ok) {
                    showStatus(status, '‚úó Error generating caption', 'error');
                } else {
                    let data = null;
                    let rawText;
                    try {
                        rawText = await res.text();
                        console.log('RAW_TEXT_FROM_CAPTION_WEBHOOK:', rawText);
                        data = JSON.parse(rawText);
                    } catch (e) {
                        console.warn('Caption webhook did not return JSON or parsing failed.', e);
                        console.error('Raw response text that failed to parse:', rawText || '(could not read text)');
                    }

                    captionBox.style.display = 'block';

                    const caption =
                        (data && (data.caption || data.text || data.captionText)) ||
                        'Marketing text is being generated...';

                    currentCaption = caption;
                    captionText.value = caption;
                    showStatus(status, '‚úì Caption ready', 'success');
                    setButtonLocked(telegramBtn, false);
                    const ft = document.getElementById('finalTelegram');
                    if (ft) { ft.disabled = false; ft.classList.remove('btn-locked'); }
                    setNextStepGlow(telegramBtn);
                }
            } catch (err) {
                stopPersonaCycle();
                showStatus(status, '‚úó Network error: ' + err.message, 'error');
            }
            if (captionBtn) {
                setButtonLocked(captionBtn, false);
                captionBtn.textContent = 'üìù Generate Marketing Post';
            }
        }

        async function sendToTelegram() {
            if (!selectedProduct) return;
            const status = document.getElementById('step2Status');
            showStatus(status, 'üöÄ Sending to Telegram...');
            telegramBtn.disabled = true;
            console.log('SENDING REQUEST FOR MODEL (telegram):', selectedModel);

            // Format scene as 'Category - Scene Name' instead of comma-separated
            const formattedScene = selectedScene.includes(',') 
                ? selectedScene.replace(',', ' - ') 
                : selectedScene;

            // Ensure Alma's reference image URL is correct
            let modelUrl = selectedProduct.modelUrl;
            if (selectedModel === 'Alma') {
                modelUrl = 'https://res.cloudinary.com/dtapjwtqw/image/upload/v1769810294/liranhe_Glamorous_portrait_of_a_captivating_woman_with_exotic_f_90e9b0f9-f99e-4553-9a00-cc7f73a3c494_f7ffkh.png';
            }

            const captionValue = currentCaption || (captionText && captionText.value) || '';
            const imgEl = document.getElementById('generatedImage');
            const imageUrl = currentImageUrl || (imgEl && imgEl.src ? imgEl.src : '');

            const payload = {
                source: 'Web_App',
                product_id: selectedProduct.id,
                rowNumber: selectedProduct.rowNumber,
                product: selectedProduct.title,
                model: selectedModel,
                collection: selectedProduct.collection,
                model_url: modelUrl,
                scene: formattedScene,
                situation: formattedScene, // Add situation field with formatted value
                caption: captionValue,
                image_url: imageUrl,
                command: 'Approve & Post'
            };

            try {
                const res = await fetch(WEBHOOK_CAPTION, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (res.ok) {
                    showStatus(status, '‚úì Sent to Telegram!', 'success');
                    // Data cleanup: mark run as complete and ignore any stale statuses
                    lastSeenStatus = '';
                    generationPhase = 'idle';
                } else {
                    showStatus(status, '‚úó Error sending to Telegram', 'error');
                }
            } catch (err) { showStatus(status, '‚úó Network error: ' + err.message, 'error'); }
            telegramBtn.disabled = false;
        }

        init();
    </script>
</body>
</html>


